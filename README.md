В проекте реализованы основные алгоритмы для генерации пресета армии компьютера, пошаговой симуляции боя, поиска подходящих целей и прокладки кратчайшего пути. Все компоненты интегрированы с игровым движком и соответствуют ТЗ по корректности и временной сложности.

## Реализация метода generate интерфейса GeneratePreset

Данный метод формирует пресет армии компьютера.

Сложность 

сортировка типов: O(n log n) + последовательное заполнение: O(n) → итог O(n log n) (n — число типов юнитов);

## Реализация метода simulate интерфейса SimulateBattle.

Данный метод осуществляет симуляцию боя между армией игрока и армией компьютера. 

Бой проходит раундами; в каждом раунде формируется единая очередь всех живых юнитов, сортируемая по убыванию атаки; юниты по очереди выполняют атаки (unit.getProgram().attack(), результаты логируются; погибшие юниты сразу исключаются, очередь пересчитывается; бой завершается при отсутствии возможных атак.

Сложность:

•	Сортировка - O(n log n)

•	O(n * m). (где n - количество юнитов в армии игрока, а m - количество юнитов в армии противника)

•	В итоге O(n * m)

## Реализация метода getSuitableUnits интерфейса SuitableForAttackUnitsFinder

Метод определяет список юнитов, подходящих для атаки, для атакующего юнита одной из армий.

Цель считается подходящей, если она жива и не закрыта другим юнитом со стороны направления атаки (проверка соседней клетки по оси y, построчно — 3 ряда).

Сложность: 

⦁ при фиксированном числе рядов (m = 3): O(n) по числу ячеек в ряду; 

⦁ в общем виде проход по матрице O(n * m). (n - количество строк, m - количество юнитов в строке)

## Реализация метода getTargetPath интерфейса UnitTargetPathFinder

Метод определяет кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка объектов содержащих координаты каждой точки данного кратчайшего пути.

Игровое поле как граф (W × H вершин); перемещения по 8 направлениям (включая диагонали); клетки с живыми юнитами считаются препятствиями; восстановление пути через карту предков; при отсутствии пути возвращается пустой список.

Сложность:

O(n * m * log(n * m)). (гд n - ширина, а m - высота поля)


